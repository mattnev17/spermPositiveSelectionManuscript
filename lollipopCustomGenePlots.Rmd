---
title: "nanoseqLollipopGenePlots"
author: "Matt Neville"
date: '2022-07-12'
output: html_document
---

# 1. Prep
## Paths/Libraries
```{r setup}
inputPublic <- "PublicTwinsUKCode/dataPublic/"
inputControlled <- "PublicTwinsUKCode/dataControlled/"
outputPath <- "PublicTwinsUKCode/output/"

library(httr)
library(dndscv)
library(Biostrings)
library(GenomicRanges)
library(org.Hs.eg.db)
library(MetBrewer)
library(egg)
library(patchwork)
library(plyr)
library(scales)
library(ggpubr)
library(ggchicklet)
library(tidyverse)
```

## Load Datasets
```{r loadDatasets}

## dataframe that holds list number in RefCDS object for each gene; so you can easily extract your gene of interest cds intervals
## load dnds hg37 refCDS object from dNdS -> to get coding sequence intervals
data("refcds_hg19", package = "dndscv")
genes <- as.data.frame(matrix(nrow=length(RefCDS), ncol=2))
colnames(genes) <- c("gene_name","row_in_refcds")
for( i in 1:length(RefCDS)){
  genes$gene_name[i] <- RefCDS[[i]]$gene_name
  genes$row_in_refcds[i] <- i
}

## load dnds object to annotate muts and colour by impact
annotmuts <- read_tsv(paste0(inputControlled, "dNdSannotMuts.tsv"), col_types = cols())
## merge nanoseq_data with dnds annotations and clinvar annotations
nanoseq_data <- read_tsv(paste0(inputControlled, "collapsedTargVars.tsv"), col_types = cols()) |> 
  mutate(sampleID = str_sub(PD_ID, 1, 7)) |> 
  dplyr::select(sampleID, chr, pos = start, ref, mut = alt, clinvarPathogenic = ClinVar) |> 
  distinct() |> 
  left_join(annotmuts,by=c("sampleID","chr","pos","ref","mut")) |>  
  mutate(label = if_else(clinvarPathogenic, "P", "")) |>
  # rename cols to match nanoseq_data colnames
  dplyr::rename(CHROM = chr,
         POS = pos,
         REF = ref,
         ALT = mut) |> 
  mutate(impact = replace_na(impact, "Non-coding")) |> 
  mutate(impact = str_replace(impact, "no-SNV", "Indel")) |> 
  mutate(name = if_else(impact == "Indel", 
                        #Formating for indels
                        replace_na(str_remove(ntchange, ".*-"), ".") |> 
                          str_replace("frshift", "FS") |> 
                          str_replace("inframe", "IF"), 
                        #Name for SNVs
                        replace_na(aachange, "."))) 

#Set colours for variant csq
mutType_colours <- c("Non-coding" = "grey100",
                     "Synonymous" = "gray70",
                     "Missense" = "cadetblue",
                     "Nonsense" = "darkorchid4",
                     "Indel" = "chocolate3",
                     "Essential_Splice" = "darkorchid2",
                    "Stop_loss" = "#f9d14a")

# Optionally include COSMIC cancer vars for comparison. This file can be generated by downloading the Whole Genome/Exome COSMIC data (have avoiding targeted data due to coverage bias), adding it as input to dnds and then saving the annotmuts object from output
cosmicVarsAnnot <- read_tsv("COSMIC_v99_WholeGenomeExome_dNdSAnnotatedMuts.tsv", col_types = cols()) |> 
  select(-c(sampleID, mstr)) |> 
  mutate(impact = str_replace(impact, "no-SNV", "Indel")) |> 
  group_by_all() |> summarise(count = n(), .groups = "drop")

```


# 2. Coverage
Total coverage across all samples per bp in bed format. File created in targ_exome_nanoseq.Rmd scipt
## Read into R
```{r cov}
#Coverage summaries
totTargCov <- read_tsv(paste0(inputControlled, "totalCovMerged_PosGenes.bed"), col_types = "c-dd", col_names = c("chr", "pos", "cov"))

```

## Protein domains
```{r domains}

getProteinDomains <- function(geneInput) {
  APIurl <- "https://www.ebi.ac.uk/proteins/api/" # base URL of the API
  taxid <- "9606" # human tax ID
  gene <- geneInput # target gene
  orgDB <- "org.Hs.eg.db" # org database to get the uniprot accession id
  eid <- mget(gene, get(sub(".db", "SYMBOL2EG", orgDB)))[[1]]
  chr <- mget(eid, get(sub(".db", "CHR", orgDB)))[[1]]
  accession <- unlist(lapply(eid, function(.ele){
    mget(.ele, get(sub(".db", "UNIPROT", orgDB)))
  }))
  stopifnot(length(accession)<=20) # max number of accession is 20
  
  # Need to manually select which protein ID for some genes
  if(geneInput %in% c("SMAD4", "KRAS")) {
    accession <- accession[2]
  } else (accession <- accession[1])
  
  
  featureURL <- paste0(APIurl, 
                         "features?offset=0&size=-1",
                       # "features?offset=0&size=-1&reviewed=true",
                         "&categories=DOMAINS_AND_SITES",
                         "&taxid=", taxid,
                         "&accession=", paste(accession, collapse = "%2C"))
  response <- GET(featureURL)
  if(!http_error(response)){
    content <- httr::content(response)
    if(length(content) == 0) {
      domains <- tibble()
      return(domains)
    } else {
      content <- content[[1]]

      domains <- as_tibble(suppressWarnings(do.call(rbind, content$features))) 
      return(domains)
    }
   } else{
    message("Can't get features. http error")
    }
}

geneDomainsCollect <- tibble()
for (gene in goiInterest) {
  geneDomains0 <- getProteinDomains(gene) |> mutate(gene = gene)
  geneDomainsCollect <- geneDomainsCollect |> bind_rows(geneDomains0)
}


# Protein domain info can get messy, vary a lot by gene, and sometimes needs to be shortened to plot properly. Commented code below is the steps needed for the 40 sperm selection genes. If you run it without customizing to your gene list it might have different columns etc that will throw errors, you'll need to customize (or not label protein domains)
geneDomains <- geneDomainsCollect |> 
  mutate_all(as.character)  
# |>
   # mutate(ligand = str_extract(ligand, '".*?"')) |>
   # mutate(ligand = str_replace_all(ligand, '"', '')) |>
   # mutate(ligand = if_else(str_detect(ligand, "ECO"), "", ligand)) |>
   # mutate(description = if_else(type == "BINDING",paste0(ligand, " binding"), description)) |>
   # # Keep only GTP binding
   # mutate(type = if_else(description %in% c("GTP binding"),"BINDING_Keep", type)) |>
   # filter(!type %in% c("REGION", "COILED", "SITE", "MOTIF", "ACT_SITE", "BINDING")) |>
   # filter(!str_detect(description, "Breakpoint for translocation")) |>
   # filter(!str_detect(description, "Tyrosine specific protein phosphatases")) |>
   # mutate(recStart = as.numeric(begin)*3 - 2) |>
   # mutate(recEnd = as.numeric(end)*3) |>
   # select(-c(evidences, molecule, ligand, begin, end)) |>
   # #Gene specific edits
   # mutate(description = str_replace(description, "17beta-hydroxy-5alpha-androstan-3-one", "Dihydrotestosterone")) |>
   # mutate(description = str_replace(description, "S-adenosyl-L-methionine", "SAMe")) |>
   # mutate(description = if_else(type == "REPEAT" & str_detect(description, "ANK"), "ANK", description)) |>
   # mutate(description = if_else(type == "DNA_BIND", "DNA binding", description)) |>
   # mutate(description = if_else(type == "ZN_FING", "Zn finger", description)) |>
   # filter(!str_detect(description, "Zn\\(2")) |> filter(!str_detect(description, "Ca\\(2")) |>
   # mutate(description = if_else(str_detect(description, "Fibronectin type-III"), "FN3", description)) |>
   # mutate(description = if_else(str_detect(description, "Ig-like C2-type"), "C2-set", description)) |>
   # mutate(description = if_else(str_detect(description,"ANK") & gene == "ANKRD11" & recStart == 598, "ANK repeats", description)) |>
   # mutate(description = if_else(str_detect(description,"ANK") & gene == "ANKRD11" & recStart != 598, "", description)) |>
   # mutate(description = if_else(str_detect(description,"ANK") & gene == "MIB1" & recStart == 1684, "ANK repeats", description)) |>
   # mutate(description = if_else(str_detect(description,"ANK") & gene == "MIB1" & recStart != 1684, "", description)) |>
   # filter(!(type == "ZN_FING" & gene %in% c("AR", "NSD1"))) |>
   # mutate(description = if_else(str_detect(description, "Cbl-PTB"), "Cbl-type phosphotyrosine-binding", description)) |>
   # mutate(description = if_else(gene == "SEMG1", paste0(description, " repeat"), description)) |>
   # filter(!(gene == "ARHGAP35" & description == "GTP binding"))
```

# 3. Plot
## Plotting functions
```{r cov}
# jitterLables and reAdjustLabels adapted from lolliplots package
jitterLables <- function(coor, xscale, lineW, weight=1.2){
    if(weight==1.2) {
      stopifnot("Please sort your inputs by start position"= 
                  order(coor)==1:length(coor))
    }
    if(weight<0.5) return(coor)
    stopifnot(length(xscale)==2)
    pos <- (coor-1)/(xscale[2]-1)
    # pos <- convertX(unit(coor01, "native"), "npc", valueOnly=TRUE)
    pos.diff <- diff(c(0, pos, 1))
    idx <- which(pos.diff < weight*lineW)
    if(length(idx)<1){
        return(coor)
    }
    if(all(idx %in% c(1, length(pos)+1))){
        return(coor)
    }
    idx.diff <- diff(c(-1, idx))
    idx.grp <- rle(idx.diff)
    idx.grp$values[idx.grp$values==1] <- length(pos) + 1:sum(idx.grp$values==1)
    idx.grp <- inverse.rle(idx.grp)
    idx.grp.w <- which(idx.grp>length(pos))-1
    idx.grp.w <- idx.grp.w[idx.grp.w>0]
    idx.grp[idx.grp.w] <- idx.grp[idx.grp.w+1]
    idx.grp <- split(idx, idx.grp)
    flag <- as.numeric(names(idx.grp))>length(pos)
    idx.grp.mul <- lapply(idx.grp[flag], function(.ele){
        c(.ele[1]-1, .ele)
    })
    idx.grp.sin <- lapply(idx.grp[!flag], function(.ele){
        lapply(as.list(.ele), function(.ele){c(.ele-1, .ele)})
    })
    idx.grp.sin <- unlist(idx.grp.sin, recursive = FALSE)
    idx.grp <- c(idx.grp.mul, idx.grp.sin)
    
    adj.pos <- lapply(idx.grp, function(.ele){
        .ele <- .ele[.ele>0 & .ele<=length(pos)]
        this.pos <- pos[.ele]
        names(this.pos) <- .ele
        if(length(this.pos)%%2==1){
            center <- ceiling(length(this.pos)/2)
        }else{
            center <- length(this.pos)/2 + .5
        }
        if(length(this.pos)>5){ ## too much, how to jitter?
            this.pos <- this.pos + 
                ((1:length(this.pos))-center) * (weight-.1) * 
                lineW/ceiling(log(length(this.pos), 5))
        }else{
            this.pos <- this.pos + 
                ((1:length(this.pos))-center) * (weight-.1) * lineW
        }
        this.pos
    })
    names(adj.pos) <- NULL
    adj.pos <- unlist(adj.pos)
    coor[as.numeric(names(adj.pos))] <- adj.pos*diff(xscale)+xscale[1]
    
    Recall(coor, xscale=xscale, lineW=lineW, weight=weight-0.2)
}

reAdjustLabels <- function(coor, lineW, xmax){
  # resort
  coor <- sort(coor)
  bins <- ceiling(1/lineW)
  pos <- (coor-1)/(xmax-1)
  # pos <- convertX(unit(coor, "native"), "npc", valueOnly=TRUE)
  pos.bin <- cut(pos, c(-Inf, (0:bins)*lineW, Inf), labels=0:(bins+1), right=FALSE)
  
  ## split the coors by into clusters
  ## give the clusters with more idx more spaces if there are spaces between clusters
  tbl <- table(pos.bin)
  if(all(tbl<2)) return(coor)
  tbl.len <- length(tbl)
  if(tbl.len<3) return(coor)
  loops <- 1000
  loop <- 1
  while(any(tbl==0) && any(tbl>1) && loop < loops){
    tbl.bk <- tbl
    for(i in order(tbl.bk, decreasing=TRUE)){
      if(tbl[i]>1 && tbl.bk[i]==tbl[i]){
        if(i==1){
          if(tbl[2]<tbl[1]){
            half <- sum(tbl[1:2])/2
            tbl[2] <- ceiling(half)
            tbl[1] <- floor(half)
          }
        }else{
          if(i==tbl.len){
            if(tbl[tbl.len]>tbl[tbl.len-1]){
              half <- sum(tbl[(tbl.len-1):tbl.len])/2
              tbl[tbl.len-1] <- ceiling(half)
              tbl[tbl.len] <- floor(half)
            }
          }else{
            if(tbl[i-1]<tbl[i+1]){
              ## i-1 and i should be balanced
              half <- sum(tbl[(i-1):i])/2
              tbl[i-1] <- floor(half)
              tbl[i] <- ceiling(half)
            }else{
              half <- sum(tbl[i:(i+1)])/2
              tbl[i] <- floor(half)
              tbl[i+1] <- ceiling(half)
            }
          }
        }
      }
    }
    loop <- loop + 1
  }
  coef <- unlist(lapply(tbl, function(.ele){
    if(.ele==0) return(0)
    .ele <- seq(from=0, to=1, length.out=.ele+1)
    (.ele[-length(.ele)] + .ele[-1])/2
  }))
  coef <- coef[coef!=0]
  coor <- (rep(as.numeric(names(tbl)), tbl) - 1 + coef) * lineW
  # coor <- convertX(unit(coor, "npc"), "native", valueOnly=TRUE)
  coor = ((xmax-1) * coor) + 1
  coor
}

# Covert genomic bp to coding sequence coordinate 
getCDSindex <- function(intervals) {
  strand <- intervals$strand[1]
  allBP <- tibble()
  for(exon in 1:length(intervals$length)) {
    exonBP <- tibble(pos = seq(intervals$start[exon], intervals$end[exon]))
    allBP <- bind_rows(allBP, exonBP) 
  }
  # Forward strand standard
  if(strand == 1) {
  allBP <- allBP |> 
      mutate(cdsPos = seq(1:sum(intervals$length)))    
  } else {
    #Reverse strand flip cds coords so all genes show left to right
    allBP <- allBP |> 
      mutate(cdsPos = seq(from = sum(intervals$length), to = 1))  
  }
  return(allBP)
}

#For a mutation outside the CDS (splice or non-coding) set its CDS position as .5 off the nearest exon border
getCDSindexNonCDS <- function(cdsCoordsIndex, vars, strand) {
  nonCDSvars <- vars |> filter(impact %in% c("Essential_Splice", "Non-coding") | (impact == "Indel" & is.na(ntchange) & !POS %in% c(225360683)))#edge case
  closestCDS <- cdsCoordsIndex |> dplyr::slice(rep(1:n(), each = dim(nonCDSvars)[1])) |> 
    mutate(nonCDSpos = rep(nonCDSvars$POS, times = dim(cdsCoordsIndex)[1])) |> 
    mutate(gap = nonCDSpos - pos) |> 
    mutate(absGap = abs(gap)) |> 
    group_by(nonCDSpos) |> filter(absGap == min(absGap)) |> 
    ungroup() |> 
    #flip direction if reverse strand
    mutate(gap = gap * strand) |> 
    #Set offset based on strand direction
    mutate(cdsPos = if_else(gap < 0, cdsPos - 0.5, cdsPos + 0.5)) |> 
    select(POS = nonCDSpos, cdsPos)
  return(closestCDS)
}
```

## Lolliplot
Loops through selected genes, outputs file
```{r lolliplot, fig.height= 7, fig.width=13}

## define genes of interest by dNdS sig genes or by custom list of gene names (example below)
goi <- c("SMAD4", "CUL3", "FGFR3")

#Plot Settings

#True means drop non-coding (intronic) mutations, False means keep (will show at exon borders)
filterNonCoding = T
#Controls how spaced variant points will be. If you change pdf output size, you may need to adjust this
pointWidth = 0.017
# Coverage height. Control what the max y value of duplex coverage background is. Reduce with lower average coverage or increase with more
covMax = 200000

## loop over genes
for(g in 1:length(goi)){
g_CDS <- RefCDS[[which(genes$gene_name==goi[g])]]

intervals_cds0 <- tibble(chr = g_CDS$chr,
                        strand = g_CDS$strand,
                        start = g_CDS$intervals_cds[,1],
                        end = g_CDS$intervals_cds[,2]) |> 
  arrange(start) |>
  mutate(length = (end + 1) - start) 

cdsCoordsIndex <- getCDSindex(intervals_cds0)

intervals_cds <- intervals_cds0 |> 
  left_join(cdsCoordsIndex |> select(start = pos, cdsStart = cdsPos), by = "start") |> 
  left_join(cdsCoordsIndex |> select(end = pos, cdsEnd = cdsPos), by = "end")

# Coverage
geneCov <- cdsCoordsIndex |> 
  left_join(totTargCov, by = join_by(pos)) |> 
  filter(chr == g_CDS$chr) |> select(-chr) |> 
  mutate(cov = replace_na(cov, 0))

# subset nanoseq_data to variants in the gene
# Can choose to filter non-coding variants or not
gene0 <- nanoseq_data |> filter(CHROM == intervals_cds$chr[1] & POS >= min(intervals_cds |> pull(start)) & POS <= max(intervals_cds |> pull(end))) |> 
  group_by_at(vars(-sampleID)) |> summarize(count = n(), .groups = "drop")
  
gene <- gene0 |> 
  filter(if (filterNonCoding) impact != "Non-coding" & !(impact == "Indel" & is.na(ntchange) & clinvarPathogenic == F)) |> 
  left_join((cdsCoordsIndex |> dplyr::rename(POS = pos) |> bind_rows(getCDSindexNonCDS(cdsCoordsIndex, gene0, strand = intervals_cds$strand[1]))), by = "POS") |> 
  arrange(cdsPos) |> 
  drop_na(cdsPos) |>
  mutate(label = replace_na(label, " ")) |> 
  mutate(name = if_else(count < 2 & gene == "NF1", " ", name))  
  
# Cosmic Vars
geneCosmic <- cosmicVarsAnnot |> 
  filter(chr == intervals_cds$chr[1] & pos >= min(intervals_cds |> pull(start)) & pos <= max(intervals_cds |> pull(end))) |> 
  left_join(cdsCoordsIndex, by = "pos") |> 
  drop_na(cdsPos)
  
  # Set label position with lolliplot functions
  lab.pos <- jitterLables(gene |> arrange(cdsPos) |> pull(cdsPos), 
                          xscale=c(1, max(cdsCoordsIndex |> pull(cdsPos))), 
                          lineW=pointWidth)
  
  lab.pos <- reAdjustLabels(lab.pos, lineW=pointWidth, xmax = max(cdsCoordsIndex |> pull(cdsPos)))
  
  variants <- gene |> 
    mutate(labPos = lab.pos) |> mutate(aachange = replace_na(aachange, ".")) |> 
    mutate(impact = fct_relevel(impact, names(mutType_colours))) |> 
    suppressWarnings()
  

  xMax <- max(c(intervals_cds$cdsEnd,intervals_cds$cdsStart)) + max(c(intervals_cds$cdsEnd,intervals_cds$cdsStart))*0.02
  
  xMin <- 1 - xMax*0.01
  
  if(min(variants$labPos<xMin)) {xMin <- 1 - xMax*0.02}
  
  legendPos <- c(0.5, 0.95)
  if (goi[g] %in% c("FGFR3", "RIT1")) {legendPos <- c(0.8, 0.95)}
  
  yMaxCount <- max(variants |> pull(count)) + 2 
  if (yMaxCount > 10) {yMaxCount = yMaxCount + 2}
  pCov <- ggplot(variants, aes(x = cdsPos, y = count)) + 
    #Coverage area
    geom_area(data = geneCov |> mutate(count = cov/(covMax/yMaxCount)), fill = '#ccece6') +
    #Variant stems
    geom_segment(data = variants, aes(x=cdsPos, xend=cdsPos, y=0, yend= (0.2 * count))) +
    geom_segment(data = variants, aes(x=cdsPos, xend=labPos, y=(0.2 * count), yend=(0.3 * count))) +
    geom_segment(data = variants, aes(x=labPos, xend=labPos, y=(0.3 * count), yend=(count))) +
    #Variant points
    geom_point(data = variants, aes(x = labPos, y = count, fill=impact), shape=21,  color="black", size=5) +
    #Label aa change
    geom_text(data = variants, aes(label = name, x = labPos, y = (count + yMaxCount/8)), angle = 90) + 
   ggtitle(goi[g]) +
    #Label clinvar
    geom_text(data = variants, aes(label = label, x = labPos, y = (count)), size=3.5) +
    scale_fill_manual(guide = "legend", values = mutType_colours) +
    scale_x_continuous(expand = c(0, 0), limits = c(xMin, xMax)) +
    ylab("Sperm samples with mutation") +
    coord_cartesian(clip = "off") +
    scale_y_continuous(limits = c(0, yMaxCount), expand = c(0, 0), sec.axis = sec_axis(~ . * (covMax/yMaxCount), name = "Duplex Coverage")) +
    theme(
      panel.background = element_rect(fill = "transparent", colour = NA),
      plot.background = element_rect(fill = "transparent", colour = NA),
      panel.grid = element_blank(),
      panel.border = element_blank(),
      plot.margin = unit(c(0.5, 0.5, 0, 0.5), "cm"),
      panel.spacing = unit(c(0, 0, 0, 0), "cm"),
      axis.text.y = element_text(margin = margin(0,0.3,0,0.2, "cm")),
      axis.ticks = element_blank(),
      axis.text.x = element_blank(),
      axis.title.x = element_blank(),
      axis.line = element_blank(),
      plot.title = element_text(hjust = 0.5),
      axis.ticks.length.x = unit(0, "null"),
      legend.position = legendPos,
      legend.direction = "horizontal",
      legend.title = element_blank(),
      legend.key = element_rect(fill = NA)) 

  # Adjust min max for strand 
  if(intervals_cds$strand[1] == 1) {
    intervals_cds2 <- intervals_cds |> 
      rename(recStart = cdsStart, recEnd = cdsEnd)
  } else {
    intervals_cds2 <- intervals_cds |> 
      rename(recStart = cdsEnd, recEnd = cdsStart)
  }

  domainsPlotObject <- intervals_cds2 |> mutate(type = "exon") |> 
    bind_rows(geneDomains |> filter(gene == goi[g]) |> mutate(type = "domain")) |> 
    select(recStart,recEnd, description, type) |> 
    mutate(description = replace_na(description, "")) |> 
    mutate(height = if_else(type == "exon", 0.75, 1)) |> 
    mutate(base = if_else(type == "exon", 0.25, 0)) 
    
  pDomains <- ggplot(domainsPlotObject, aes(xmin = recStart, xmax = recEnd, ymin = base, ymax = height, label = description)) +
    ggchicklet:::geom_rrect(aes(alpha = type, fill = type), colour = "grey60", r = unit(0.2, 'npc')) +
    scale_alpha_manual(values = c(0.8, 1)) +
    scale_fill_manual(values = c("#d0d1e6", "#fa9fb5")) +
    geom_text(aes(x = (recStart + recEnd)/2, y = 0.5), size = 2.5) +
    theme_void() + 
    xlab("CDS") +
    scale_x_continuous(expand = c(0, 0), limits = c(xMin,xMax)) +
    scale_y_continuous(expand = c(0, 0)) +
    theme(plot.margin = unit(c(0, 0.5, 0, 0.5), "cm")) + guides(alpha = "none", fill = "none")
  
  
  pCosmic <- ggplot(geneCosmic, aes(x = cdsPos, y = count, colour = impact)) +
    #Cosmic vars
    geom_col() +
    scale_colour_manual(guide = "legend", values = mutType_colours) +
    scale_x_continuous(expand = c(0, 0), limits = c(xMin,xMax)) +
    scale_y_reverse(expand = c(0, 0)) +
    # scale_y_continuous(
    # trans  = compose_trans("log10", "reverse"),expand = c(0, 0)) +
    ylab("COSMIC cancer count") +
    theme(
      panel.background = element_rect(fill = "transparent", colour = NA),
      plot.background = element_rect(fill = "transparent", colour = NA),
      panel.grid = element_blank(),
      panel.border = element_blank(),
      plot.margin = unit(c(0, 0.5, 0.5, 0.5), "cm"),
      panel.spacing = unit(c(0, 0, 0, 0), "cm"),
      axis.text.y = element_text(margin = margin(0,0.3,0,0.2, "cm")),
      axis.ticks = element_blank(),
      axis.text.x = element_blank(),
      axis.title.x = element_blank(),
      axis.line = element_blank(),
      plot.title = element_text(hjust = 0.5),
      axis.ticks.length.x = unit(0, "null"),
      legend.position = "none"
    ) 
  print(pCov/pDomains/pCosmic + plot_layout(heights = c(15,2,10)))
  filename <- paste0(outputPath, goi[g],"_cosmiclollipop.png")
  png(filename, height = 7, width = 11, res = 300, units = "in")
  print(pCov/pDomains/pCosmic + plot_layout(heights = c(15,2,10)))
  dev.off()
  
}



  
```

